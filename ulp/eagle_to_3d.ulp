#usage "<b>Generate IDF files and interface to SimplifiedSolutionsinc.com to generate 3D model.</b><p>\n"
       "Generates the EMN and EMP IDF files from the board.<BR>"
	   "IDF files are then submitted to SimplifiedSolutionsinc.com<br/>"
	   "and a 3D assembly model is generated. On the SimplifiedSolutionsinc.com<BR/>"
	   "site mappings are executed from the board elements to fully rendered<BR>"
	   "3D models. The site then responses with a thumbnail and several free and<br/>"
	   "purchase options.<BR>"
	   "Version: 1.0 - Initial Release - 4-30-12<br/>"
	   "Version: 1.1 - Includes banner and dynamic library logic - 5-5-12<br/>"
	   "Version: 1.2 - Includes fix for board outline loop order and improved logic for component outlines - 5-9-12<br/>"
	   "Version: 1.3 - Includes fix for zero value max/min x/y values on component outlines - 5-10-12<br/>"
	   "Version: 1.4 - Includes fix for missing holes - 5-12-12<br/>"
	   "Version: 1.5 - Modified banner url for dynamic version based message. Fix in board outline for lines linked end to end vs end to start. Updated text in UI. - 5-13-12<br/>"
	   "Version: 1.6 - Fix for component outlines where max/min values are equal resulting in failures in Proe - 5-14-12<br/>"
	   "Version: 1.7 - Enabled purchase links to pcb-pool site. Include UI customizations for Windows and Mac.  - 5-14-12<br/>"
	   "Version: 1.8 - Updated links shown after build completed. - 6-21-12<br/>"
	   "Version: 1.9 - UI updates based on feedback. Added in third link to enable user to continue working on board. - 7-1-12<br/>"
	   "Version: 2.0 - UI fixes for Mac/Linux - 7-2-12<br/>"
	   "Version: 2.1 - Updated UI on page. - 7-8-12<br/>"
	   "Version: 2.2 - Improved board outline algorithm. - 7-10-12<br/>"
	   "Version: 2.3 - Changed port number to 8080. 9-17-12<br/>"
	   "Version: 2.3b - Fix for space in generation of .placement section values. - 7-30-12<br/>"
	   "Version: 3.0 - Improvements to handling of outline defects and swap package/value in writing to IDF files. Fixed issue with unique alname/ecad outlines in emp. Includes logic to handle boards with circle outline. - 9-13-12<br/>"
	   "Version: 3.1 - Changed over ports to 80. - 11-6-12<br/>"
	   "Version: 3.2 - Changing wording on fatal defect dialog - 11-23-12<br/>"
	   "Version: 3.3 - Add help and video links - 12-1-12<br/>"
	   "Version: 3.4 - Changed all links to SSI to use https - 12-9-12<br/>"
	   "Version: 4.0 - Included Secondary mapping flag. Put in cleanString() to only put numbers/letters in footprint and altname. - 1-13-13<br/>"
	   "</p>"
       "<author>Author: support@simplifiedsolutionsinc.com</author>"

#require 5.1000
string version = "4.0";  //ulp version

//vars used for the text dialog
string textMessageDialog;  //used to store text shown to user
string textMessageHeader = "<h1>Welcome to the EAGLE-to-3D Tool</h1>";
string textDisclaimer = "The 3D component libraries supplied by Simplified Solutions have been compiled with great care. However, with the large number of 3D models available and the occasional package changes made by suppliers, an occasional discrepancy is unavoidable. Please note, therefore, that Simplified Solutions and Beta LAYOUT takes no responsibility for the complete accuracy of information included in the 3D library components.  Please verify all 3D PCB STEP file geometry prior to using the data in product designs.  By choosing the \"Generate 3D Data\" button you are also agreeing to our <a href=\"http://www.simplifiedsolutionsinc.com/copy/terms_of_service.html\">Terms of Service</a>";


//web request urls
string host = "https://www.simplifiedsolutionsinc.com";
//string service_port = "8080";
string service_port = "80";
string static_port = "80";
string service_name = "EMN-EMPAdvancedApp/EagleTo3DServlet";
string static_name = "EagleTo3D/";
string service_url = host + "/" + service_name;
string static_url = host + "/" + static_name;

int useSecondaryMappings = 1;
int useSuggestionMappings = 1;

string boardThickness = "1.6";
string dummyHistory[];

//string service_url = host + ":" + service_port + "/" + service_name;
//string static_url = host + ":" + static_port + "/" + static_name;

string libraries[];  //used to hold libraries from web
string packageOutlines[];  //used to hold outlines of packages
int packageCounter = 0;  //keeps track of how many entries in packages outline array


//html used in the UI
string tagImgActive = "<img src=\""+ service_url + "/images/ajax-loader.gif\" size=\"50\">";
string tagBanner = "";    //Initial value. Once its retrieved first time it will have actual data.

//debug flags
int debug = 0;   //general debug flag
int debugIDFFile = 1;   //debug to write out local idf files
int debugIDFHtml = 0;    //debug to write out local idf files in html format

//-----------------------------------------------------------------------------
// dictionary
//-----------------------------------------------------------------------------
string Dictionary[] = {
						  "en\v"
						  "de\v",
						  "English message 1 here. \v"
						  "German message 1 here. \v",
						  "English message 2 here. \v"
						  "German message 3 here. \v"
						};

string DlgLang = language();
if (DlgLang != "de") DlgLang = "en";   //force to en if not german
int LangIdx = strstr(Dictionary[0], DlgLang) / 3;  //language index

///// Translate, based on dictionary
string tr(string s) {
	string t = lookup(Dictionary, s, LangIdx, '\v');
	return t ? t : s;
	}



//-----------------------------------------------------------------------------
// subroutines
//-----------------------------------------------------------------------------

string itos( int num ){
	string temp;

	sprintf( temp, "%d", num );

	return temp;
	}

string rtos( real num  ){
	string temp;

	sprintf( temp, "%f", num );

	return temp;
	}

int compareReals( real n1, real n2 ){
	string n1s;
	string n2s;

	sprintf( n1s, "%1.2f", n1 );
	sprintf( n2s, "%1.2f", n2 );

	if( n1s == n2s ){
		return 1;
		}
	else{
		return 0;
		}
	}

string getBoardThickness(){

	//int unitsInt;
	//string thickness;

	/* removed to force board to mm
	board(B) {
		unitsInt = B.grid.unit;
		}

	switch( unitsInt ){
		case 0: 
			thickness = "1.6";
			break;
		case 1: 
			thickness = "1.6";
			break;
		case 2: 
			thickness = "1.6";
			break;
		case 3: 
			thickness = "1.6";
			break;

		}  //end switch
	*/

	//thickness = "1.6";

	if( boardThickness == "" ){
		boardThickness = "1.6";
		}

	//check if first char is decimal and if it is then add 0
	char dec = '.';
	int pos = strchr( boardThickness, dec );
	if (pos == 0){
		boardThickness = "0" + boardThickness;
		}

	//return form value
	return boardThickness;
	}  //end func

string getBoardUnits(){

	/*
		GRID_UNIT_MIC microns
		GRID_UNIT_MM millimeter
		GRID_UNIT_MIL mil
		GRID_UNIT_INCH inch
		*/

	/* force to mm
	string unitsMap[] = { "MIC", "MM", "MIL", "IN" };

	board(B) {
		return unitsMap[ B.grid.unit ];
		}
	*/
	
	return "MM";
	}


real backConvertDimensions( real mmDim ){
	real boardDim;
	int unitsInt;

	//get board dimensions
	board(B) {
		unitsInt = B.grid.unit;
		}

	/*
	GRID_UNIT_MIC microns
	GRID_UNIT_MM millimeter
	GRID_UNIT_MIL mil
	GRID_UNIT_INCH inch
	*/

	switch( unitsInt ){
		case 0: 
			//micron
			boardDim = mmDim * 1000;
			break;
		case 1: 
			//mm
			boardDim = mmDim;
			break;
		case 2: 
			//mil
			boardDim = mmDim * 39.3700787;
			break;
		case 3: 
			//inch
			boardDim = mmDim * 0.0393701;
			break;

		}  //end switch

		//string unitsMap[] = { "MIC", "MM", "MIL", "IN" };

		//dlgMessageBox( "MM:" + rtos( mmDim ) + ", " + unitsMap[ unitsInt ] + ": " + rtos( boardDim ) );

		return boardDim;

	}  //end func

real getDimInBoardUnits( int dim ){
	int unitsInt;
	real convDim;

	/* removed for force to mm
	board(B) {
		unitsInt = B.grid.unit;
		}

	switch( unitsInt ){
		case 0: 
			convDim = u2mic( dim );
			break;
		case 1: 
			convDim = u2mm( dim );
			break;
		case 2: 
			convDim = u2mil( dim );
			break;
		case 3: 
			convDim = u2inch( dim );
			break;

		}  //end switch
	*/

	convDim = u2mm( dim );

	return convDim;
	}  //end func


real getTolerance(){
	int unitsInt;
	real tolerance;

	/* removed to force to mm
	board(B) {
		unitsInt = B.grid.unit;
		}

	switch( unitsInt ){
		case 0: 
			tolerance = 100;
			break;
		case 1: 
			tolerance = 0.05;
			break;
		case 2: 
			tolerance = 3.9;
			break;
		case 3: 
			tolerance = 0.004;
			break;

		}  //end switch
	*/

	tolerance = 0.05;

	return tolerance;
	}  //end func


string getBoardFilename(){
	board( BRD ){
		return filename( BRD.name );
		}  //end board
	}


string getBoardDir(){

	board( BRD ){
		return filedir( BRD.name );
		}  //end board
	}

string getBoardPath(){

	return getBoardDir() + getBoardFilename();

	}

int isWindows() {
	//Returns 1, if EAGLE is running under Windows (0 for Linux/Mac)
	if ((strsub(argv[0],0,1)=="/") && (strsub(argv[0],0,2)!="//"))
		return 0;

	return 1;
	}  //end sub

//count number of times a char shows up in a string.
int countOccurancesOfChar( string strToScan, char toMatch ){
	int count = 0;


	for (int i = 0; strToScan[i]; ++i) {
		if( strToScan[i] == toMatch ){
			count++;
			}  //end if
		}  //end for

	return count;

	}  //end sub

// Removes carriage returns from a string and replaces with <BR/>
string removeCarriageReturns( string dirtyString ){

	string cleanedString;

	for (int i = 0; dirtyString[i]; ++i) {
		if( dirtyString[i] == '\n' ){
			cleanedString += "<BR/>";
			}
		else{
			cleanedString += dirtyString[i];
			}  //end if-else
		}  //end for

	return cleanedString;
	}  //end sub

// Removes spaces in string and replaces with <S/>
string removeSpaces( string dirtyString ){

	string cleanedString;

	for (int i = 0; dirtyString[i]; ++i) {
		if( dirtyString[i] == ' ' ){
			cleanedString += "<S/>";
			}
		else{
			cleanedString += dirtyString[i];
			}  //end if-else
		}  //end for

	return cleanedString;
	}  //end sub

string cleanString( string dirtyString ){

	dirtyString = strupr( dirtyString );

	string cleanedString;

	for (int i = 0; dirtyString[i]; ++i) {
		if( dirtyString[i] == '0' ||
			dirtyString[i] == '1' ||
			dirtyString[i] == '2' ||
			dirtyString[i] == '3' ||
			dirtyString[i] == '4' ||
			dirtyString[i] == '5' ||
			dirtyString[i] == '6' ||
			dirtyString[i] == '7' ||
			dirtyString[i] == '8' ||
			dirtyString[i] == '9' ||
			dirtyString[i] == 'A' ||
			dirtyString[i] == 'B' ||
			dirtyString[i] == 'C' ||
			dirtyString[i] == 'D' ||
			dirtyString[i] == 'E' ||
			dirtyString[i] == 'F' ||
			dirtyString[i] == 'G' ||
			dirtyString[i] == 'H' ||
			dirtyString[i] == 'I' ||
			dirtyString[i] == 'J' ||
			dirtyString[i] == 'K' ||
			dirtyString[i] == 'L' ||
			dirtyString[i] == 'M' ||
			dirtyString[i] == 'N' ||
			dirtyString[i] == 'O' ||
			dirtyString[i] == 'P' ||
			dirtyString[i] == 'Q' ||
			dirtyString[i] == 'R' ||
			dirtyString[i] == 'S' ||
			dirtyString[i] == 'T' ||
			dirtyString[i] == 'U' ||
			dirtyString[i] == 'V' ||
			dirtyString[i] == 'W' ||
			dirtyString[i] == 'X' ||
			dirtyString[i] == 'Y' ||
			dirtyString[i] == 'Z' ||
			dirtyString[i] == '_' ||
			dirtyString[i] == '-' ||
			dirtyString[i] == ' ' ){
			

			cleanedString += dirtyString[i];
			}
		else{
			cleanedString += "_";
			}  //end if-else
		}  //end for

	return cleanedString;
	}  //end sub

// Removes spaces in string and replaces with <S/>
string replaceSpaceWithUnderscore( string dirtyString ){

	string cleanedString;

	for (int i = 0; dirtyString[i]; ++i) {
		if( dirtyString[i] == ' ' ){
			cleanedString += "_";
			}
		else{
			cleanedString += dirtyString[i];
			}  //end if-else
		}  //end for

	return cleanedString;
	}  //end sub


//  0-9, letters, dashes, and underscores are always safe.

// Reads in file and converts it to be used in a html form submit
string parseFileToHtmlForm( string filePath ){

	string fileContents;

	int in = fileread( fileContents, filePath );

	fileContents = removeCarriageReturns( fileContents );

	fileContents = removeSpaces( fileContents );

	//dlgMessageBox( "File input value:" + in );

	return fileContents;
	}  //end sub


string parseStringToHtmlForm( string input ){

	return removeSpaces( removeCarriageReturns( input ) );

	}  //end sub


//this function is used to get the html to show in the UI. it uses a fixed header and footer and the call sets the body.
string getHtmlText( string body ){

	string os;

	//detect if windows or other
	if( isWindows() ){
		os = "Windows";
		}
	else{
		os = "Mac/Linux";
		}
	
	string htmlHeader = "<hr size=1>" + textMessageHeader + "<hr size=1> \
							<table border=0 width=\"100%\" height=\"100%\"> \
								<tr> \
									<td width=\"100%\">";

	string htmlFooter = "</td>";

	htmlFooter += "<td>";

	//build window based on OS
	if( isWindows() ){
		htmlFooter += "<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/></td>";
		}
	else{
		htmlFooter += "<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/></td>";
		}  //end if-else
	
	
	htmlFooter += "</tr></table>";
	htmlFooter += "<hr size=1>";
	htmlFooter += "<table border=0 width=\"100%\" height=\"100%\"> \
					<tr> \
						<td align=left colspan=2>Help -  <a href=\"http://www.youtube.com/watch?v=rO96K5xgd50&feature=youtu.be\">Video: Mapping Components to 3D</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"https://www.simplifiedsolutionsinc.com/EagleTo3D/EAGLE-TO-3D-Best-Practices.pdf\">Best Practices</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"mailto:support@simplifiedsolutionsinc.com\">Contact Us</a></td> \
					</tr> \
					<tr> \
						<td align=left colspan=2></td> \
					</tr> \
					<tr> \
						<td align=left width=\"65%\">EAGLE-to-3D is a product of <a href=\"https://www.simplifiedsolutionsinc.com\">Simplified Solutions Inc.</a> and <a href=\"www.beta-layout.com\">Beta LAYOUT</a></td> \
						<td align=right>( ULP Version: " + version + "\t, OS: " + os + " )</td> \
					</tr> \
					<tr> \
						<td colspan=2><hr size=1></td> \
					</tr> \
					<tr> \
						<td colspan=2><font size=-1>" + textDisclaimer + "</font><td> \
					</tr> \
					</table><br/>";

	

	return htmlHeader + body + htmlFooter;
	}  //end sub

//general function to do url get
string getWebFile( string url_path ){

	return "";
	}

//this sub is used to get the Html banner to show on the UI. It should only need to be called once on first call
void loadBanner(){
	
	string banner;

	//do netget
	if( netget( banner, static_url + "eagle_banner.php?ulp_version=" + version + "&lang=" + language() ) ){

		if( debug ){
			dlgMessageBox( banner );
			}  //end if

		tagBanner = banner;

		}
	else{
		tagBanner = "Not retrieved";
		}  //end if-else

	}  //end sub


void loadTerms(){
	
	string term;

	//do netget
	if( netget( term, static_url + "terms.html" ) ){

		if( debug ){
			dlgMessageBox( term );
			}  //end if

		//tagBanner = banner;

		}
	else{
		//tagBanner = "Not retrieved";
		}  //end if-else

	}  //end sub


void loadLibraries(){

	//string libraries[];
	string libResponse;
	int libraryCount = 0;

	//string defaultLib[] = { "RCL", "RESISTOR" };

	//do netget
	if( netget( libResponse, static_url + "eagle_libraries.txt" ) ){

		if( debug ){
			dlgMessageBox( libResponse );
			}  //end if

		//load library string in to libraries array
		libraryCount = strsplit( libraries, libResponse, ':');

		}  //end if
	
	//in case some issue load RCL and RESISTOR as default
	if( libraryCount == 0 ){
		libraries[0] = "RCL";
		libraries[1] = "RESISTOR";
		}  //end if

	}  //end sub


real getDistBetweenPts( real x1, real y1, real x2, real y2 ){
	//dist = sqrt( ( x2 - x1 )^2 + ( y2 - y1 )^2 )

	return sqrt( pow( ( x2 - x1 ), 2 ) + pow( ( y2 - y1 ), 2 ) );

	}  //end sub

void writeToFile( string filePath, string fileContents ){

	output( filePath, "wt" ){
		printf( fileContents );
		}
	}

//-----------------------------------------------------------------------------
// emp subroutines
//-----------------------------------------------------------------------------


string getDateTime(){

	//time for date.time in header
	int now = time();
	string dateStr;

	sprintf( dateStr, "%d/%02d/%02d.%02d:%02d:%02d", t2year(now), t2month(now), t2day(now), t2hour(now), t2minute(now), t2second(now) );

	return dateStr;

	}  //end sub

//used to detect if outline should be closed by checking if point is within tolerance/radius of first point
int closeOutline( real bx1, real by1, real firstX, real firstY, real radius ){

	string temp;

	//debug
	if( debug ){
		real xCalc = pow( ( bx1 - firstX ), 2 );
		real yCalc = pow( ( by1 - firstY ), 2 );
		real radCalc = pow( radius, 2 );

		sprintf( temp, "%f + %f < %f", xCalc, yCalc, radCalc );

		dlgMessageBox( temp );
		}

	//(x-center_x)^2 + (y - center_y)^2 < radius^2
	if( ( pow( ( bx1 - firstX ), 2 ) + pow( ( by1 - firstY ), 2 ) ) < pow( radius, 2 ) ){
		return 1;
		}
	else{
		return 0;
		}

	}  //end sub

//looks up package outline and generates text for .electical section entry
string getComponentOutline( string footprint, string altname, string packageName, string units ){

	//package array = [ { packname1, maxX, maxY, minX, minY },
	//					 { packname2, maxX, maxY, minX, minY }
	//					]

	//board->Library->Package->Wires

	int foundPackage = 0;

	//lookup package name in array
	string packageNameLookup = lookup( packageOutlines, packageName, 0 );

	//check if found in lookup. if not then generate and put in array
	if( packageNameLookup == "" ){
		//if package not in lookup then generate it

		//init max/min values
		real maxX = 0, maxY = 0, minX = 0, minY;

		//loop thru all libraries to find packagename
		board(B) {

			//go into library
			B.libraries(LBR) {

				//loop thru packages in library
				LBR.packages(P){

					if( P.name == packageName ){
						
						//set found package flag
						foundPackage = 1; 

						
						
						//used to capture first loop of data
						int loopCounter = 0;  

						//loop thru wires and get max/min x/y
						P.wires(W){
							//get first data point
							if( loopCounter == 0 ){
								maxX = getDimInBoardUnits(W.x1);
								minX = getDimInBoardUnits(W.x1);

								maxY = getDimInBoardUnits(W.y1);
								minY = getDimInBoardUnits(W.y1);
								}

							if (W.arc) {
								//skip arcs for now
								}
							else {
								//max/min checks
								if( getDimInBoardUnits(W.x1) <= minX ){
									minX = getDimInBoardUnits(W.x1);
									}

								if( getDimInBoardUnits(W.x1) >= maxX ){
									maxX = getDimInBoardUnits(W.x1);
									}

								if( getDimInBoardUnits(W.y1) <= minY ){
									minY = getDimInBoardUnits(W.y1);
									}

								if( getDimInBoardUnits(W.y1) >= maxY ){
									maxY = getDimInBoardUnits(W.y1);
									}
								}  //end if-else

							loopCounter++;
							}  //end wires

						//break out of loop since match found
						break;

						}  //end if for package name match
					} //end packages loop
				}  //end libraries loop
			}  //end board loop


		//make sure found match. if not then put in default values
		string temp;

		if( foundPackage ){
			//load to array
			sprintf( temp, "%s\t%f\t%f\t%f\t%f", packageName, maxX, maxY, minX, minY );
			}
		else{
			sprintf( temp, "%s\t%f\t%f\t%f\t%f", packageName, maxX, maxY, minX, minY );
			}  //end if-else for found package check

		packageOutlines[ packageCounter ] = temp;

		packageCounter++;

		}  //end if for lookup check


	//generate outline data
	string outline = footprint + " " + altname + " " + units;

	//set default height based on units
	if( units == "MM" ){
		outline += " 1.00\n";
		}
	else if( units == "THOU" ){
		outline += " 39.37\n";
		}
	else{
		//treat as MM
		outline += " 1.00\n";
		}  //end if-else

	//map in max/min data
	string maxX = lookup( packageOutlines, packageName, 1 );
	string maxY = lookup( packageOutlines, packageName, 2 );

	string minX = lookup( packageOutlines, packageName, 3 );
	string minY = lookup( packageOutlines, packageName, 4 );

	/*rectangle based on max/min values. start in upper left and move clockwise
	0   minX   maxY
	0   maxX   maxY
	0   maxX   minY
	0   minX   minY
	0   minX   maxY
	*/

	//if max/min are all zeros then put in 1x1 block
	if( maxX == "0.000000" && maxY == "0.000000" && minX == "0.000000" && minX == "0.000000" ){
		outline += "0     1.00  -1.00 0.0\n" +
					"0     -1.00 -1.00 0.0\n" +
					"0     -1.00 1.00 0.0\n" +
					"0     1.00 1.00 0.0\n" +
					"0     1.00 -1.00 0.0\n";
		}
	else if( maxX == minX || maxY == minY ){
		outline += "0     1.00  -1.00 0.0\n" +
					"0     -1.00 -1.00 0.0\n" +
					"0     -1.00 1.00 0.0\n" +
					"0     1.00 1.00 0.0\n" +
					"0     1.00 -1.00 0.0\n";
		}
	else{
		outline += "0   " +  minX + "   " + maxY + "   0.0\n" +
				"0   " +  maxX + "   " + maxY + "   0.0\n" + 
				"0   " +  maxX + "   " + minY + "   0.0\n" + 
				"0   " +  minX + "   " + minY + "   0.0\n" + 
				"0   " +  minX + "   " + maxY + "   0.0\n";
		}   //end if-else

	return outline;

	}  //end sub

//gets the dummy component outlines for emp file based on units.
string getComponentOutlineDummy( string footprint, string altname, string units ){

	string outline = footprint + " " + altname + " " + units;

	if( units == "MM" ){
		outline += " 1.00\n" +
					"0     1.00  -1.00 0.0\n" +
					"0     -1.00 -1.00 0.0\n" +
					"0     -1.00 1.00 0.0\n" +
					"0     1.00 1.00 0.0\n" +
					"0     1.00 -1.00 0.0\n";
		}
	else if( units == "THOU" ){
		outline += " 39.37\n" +
					"0     39.37       -39.37      0.0\n" + 
					"0     -39.37      -39.37      0.0\n" + 
					"0     -39.37      39.37       0.0\n" + 
					"0     39.37       39.37       0.0\n" + 
					"0     39.37       -39.37      0.0\n";
		}
	else{
		//treat as MM
		outline += " 1.00\n" +
					"0     1.00  -1.00 0.0\n" +
					"0     -1.00 -1.00 0.0\n" +
					"0     -1.00 1.00 0.0\n" +
					"0     1.00 1.00 0.0\n" +
					"0     1.00 -1.00 0.0\n";

		}  //end if-else

	return outline;

	}  //end sub

string getEmpHeader(){
	/*
	.HEADER
	LIBRARY_FILE 3.0 "Commend International >generate_3d_data_v10-5_MJB.ulp V0.9<" 2012/03/21.12:23:09 1
	.END_HEADER
	*/

	return ".HEADER\n" +
			"LIBRARY_FILE 3.0 \"Eagle to 3D Version " + version + "\" " + getDateTime() + "\n" +
			".END_HEADER\n" ;

	}  //end sub



string getEmpElectrical(){
	/*
	.ELECTRICAL
	TSSOP16 NOREFDES MM 4876.80
	0 -2.51 -2.28 0
	0 2.51 -2.28 0
	0 2.51 2.28 0
	0 -2.51 2.28 0
	0 -2.51 -2.28 0
	.END_ELECTRICAL
	*/

	string electricalSection;

	string footprint; 
	string altname;

	string libraryLookup;

	string components[];

	string component;

	//loop thru elements on board
	board( BRD ){

		int i = 0;

		BRD.elements( E ){

			/*
			//get footpring
			footprint = E.value;

			if( footprint == "" ){
				footprint = E.name + "_" + E.package.name ;
				}
				*/

			//check if library in lookup
			libraryLookup = lookup( libraries, strupr(E.package.library), 0 );

			//debug
			if( debug ){
				dlgMessageBox( libraryLookup );
				}

			//set footprint and altname based on logic
			if( libraryLookup != "" ){
				footprint = E.package.name;
				altname = E.package.name;

				//add comment to emn for debuggin
				//placementSection += "#Resistor or rcl library found\n";
				}
			else if( E.value != "" ){
				altname = E.value;
				footprint = E.package.name;

				//add comment to emn for debuggin
				//placementSection += "#E.value present\n";
				}
			else{
				//if library is not in list and the E.value is blank then concat refid and package name
				altname = E.name + "_" + E.package.name;
				footprint = E.package.name;

				//add comment to emn for debuggin
				//placementSection += "#Fallback logic applied. Not res/rcl and E.value not found.\n";
				}

			altname = cleanString( altname );
			footprint = cleanString( footprint );

			//check if element has already been written out
			//component = lookup( components, footprint, 0 ); - fix for emp missing values

			component = lookup( components, footprint + "~" + altname, 0 );

			//if component is empty then it has not been written out yet.
			if( component ==  "" ){

				//build section by call to getComponentOutlineDummy( string footprint, string altname, string units )
				electricalSection += ".ELECTRICAL\n" +
										//getComponentOutlineDummy( footprint, altname, "MM" ) + 
										getComponentOutline( footprint, altname, E.package.name, getBoardUnits() ) + 
										".END_ELECTRICAL\n";

				//add component to components list
				//components[ i ] = footprint; - fix for emp missing values

				components[ i ] = footprint + "~" + altname;



				i++;
				}  //end if

			
			}  //end loop thru elements
		}  //end loop thru board


	return electricalSection;

	}  //end sub


string getEmpMechanical(){

	return "";
	}  //end sub


//-----------------------------------------------------------------------------
// emn subroutines
//-----------------------------------------------------------------------------
string getEmnHeader(){
	/*
	.HEADER
	BOARD_FILE 3.0 "Commend International >generate_3d_data_v10-5_MJB.ulp V0.9<" 2012/03/21.12:23:10 1
	"untitled.brd" MM
	.END_HEADER
	*/
	
	string boardName;

	//get board name
	board( BRD ){
		boardName = filename(BRD.name);
		}

	return ".HEADER\n" +
			"BOARD_FILE 3.0 \"Eagle to 3D Version " + version + "\" " + getDateTime() + "\n" +
			"\"" + boardName + "\" " + getBoardUnits() + "\n" + 
			".END_HEADER\n";


	}  //end sub

string setUsedFlag( string pt ){
	string fields[];
	int fieldCount = strsplit( fields, pt, '\t');

	return fields[0] + "\t" + fields[1] + "\t" + fields[2] + "\t" + fields[3] + "\ty\n";
	}


int isUsedPoint( string pt ){
	string fields[];
	int fieldCount = strsplit( fields, pt, '\t');

	if( fields[4] == "n\n" )
		return 0;
	else
		return 1;
	}

string isUsedPointDebug( string pt ){
	string fields[];
	int fieldCount = strsplit( fields, pt, '\t');

	return fields[4];

	}

/*
string swapPoints( string outlinePoints[], int toIndex, int fromIndex ){
	//swapPoints( outlinePoints, (i+1), j );

	string toPoints = outlinePoints[ toIndex ];
	string fromPoints = outlinePoints[ fromIndex ];

	//move toIndex to from position
	outlinePoints[ fromIndex ] = toPoints;
	outlinePoints[ toIndex ] = fromPoints;

	return outlinePoints;
	}
*/

string flipPoints( string line ){
	string fields[];

	int fieldCount = strsplit( fields, line, '\t');

	return fields[2] + "\t" + fields[3] + "\t" + fields[0] + "\t" + fields[1] + "\t" + fields[4];
	}

string getFieldFromPtString( string ptString, int index ){
	string fields[];

	// "pt 1\ttype\tx1\ty1\tx2\ty2\tsorted_flag"
	int fieldCount = strsplit( fields, ptString, '\t');

	if( fieldCount >= index ){
		return fields[ index ];
		}
	else{
		return "";
		}  //end if-else

	}  //end sub

real getX1FromPtString( string ptString ){
	return strtod( getFieldFromPtString( ptString, 0 ) );
	} //end sub

real getY1FromPtString( string ptString ){
	return strtod( getFieldFromPtString( ptString, 1 ) );
	} //end sub

real getX2FromPtString( string ptString ){
	return strtod( getFieldFromPtString( ptString, 2 ) );
	} //end sub

real getY2FromPtString( string ptString ){
	return strtod( getFieldFromPtString( ptString, 3 ) );
	} //end sub


int layerNumInUse( int layerNum ){
	//returns true=1 if layer is being used. returns 0 if layer is not used.
	int layerUsed = 0;

	board( B ){
		B.layers( L ){
			if( L.number == layerNum ){
				layerUsed = 1;
				}  //end if
			}  //layers loop
		}  //board loop

	return layerUsed;
	}


int layerIsIDFDebug( int layerNum ){
	board( B ){
		B.layers( L ){
			if( L.number == layerNum && L.name == "IDFDebug" ){
				return 1;
				}  //end if
			}  //layers loop
		}  //board loop
	
	return 0;
	}

string getIDFDebugLayerAvailNum(){

	//loop thru layers and check for name IDFDebug
	int startSearchNumber = 100;
	int layerAvail = -1;

	for (int i = startSearchNumber; i < 256; ++i){

		//if layer is not in use then use it. also have to check if layer is in use but is already idf debug
		if( !layerNumInUse( i ) ){
			layerAvail = i;
			break;
			}
		else{
			//check to make sure layer is not already idf debug
			if( layerIsIDFDebug( i ) ){
				layerAvail = i;
				break;
				}  //end if
			}  //end if-else
		}  //end for


	string temp;

	sprintf( temp, "%d", layerAvail );

	return temp;

	}  //end func


string getIDFDebugLayerNum(){

	//loop thru layers and check for name IDFDebug
	int IDFDebugLayerNum = -1;

	board( B ){
		B.layers( L ){
			if( L.name == "IDFDebug" ){
				IDFDebugLayerNum = L.number;
				}  //end if
			}  //layers loop
		}  //board loop

	string temp;

	sprintf( temp, "%d", IDFDebugLayerNum );

	return temp;

	}  //end func

string removeIDFDebugLayerCommands(){

	//check if present
	string debugLayerNum = getIDFDebugLayerNum();

	//if debugLayerNum is -1 then it doesnt exist so no delete needed.
	if( debugLayerNum == "-1" ){
		return "";
		}
	else{
		string commands;

		//commands
		//show only IDFDebugLayer
		commands += "DISPLAY -20 " + debugLayerNum + ";";


		//run group all command to select all circles
		//commands += "GROUP ALL;";

		//delete circles
		//DELETE (x y) where x y are points on circle outline
		board( B ){
			B.circles( C ){
				if( C.layer == strtol(debugLayerNum) ){

					commands += "DELETE ( " + rtos(getDimInBoardUnits(C.x)) + " " +  rtos(getDimInBoardUnits(C.y)) + " );";

					}  //end if
				}  //end wire loop 

			B.wires( W ){
				if( W.layer == strtol(debugLayerNum) ){

					commands += "DELETE ( " + rtos(getDimInBoardUnits(W.x1)) + " " +  rtos(getDimInBoardUnits(W.y1)) + " );";

					}  //end if
				}  //end wire loop 

			}  //board loop


		//delete layer now
		commands += "LAYER ?? -" + debugLayerNum + ";";


		return commands;
		}  //end if/else
	}  //end fund



int countWires(){
	int wiresCounter = 0;

	board( BRD ){
		//loop thru wires
		BRD.wires(W){
			if (W.layer == 20){

				if ( W.arc ){
					wiresCounter++;
					}
				else{
					wiresCounter++;
					}  //end if-else
				}  //end if for layer 20
			}  //end loop thru wires
		}  //end loop thru board

	return wiresCounter;
	}


int countWireHoles(){
	int holeCount = 0;
	
	board( BRD ){
		/*
		BRD.holes(H){ 

			holeCount++;
			}  //end holes
			*/

		BRD.circles(C){
			if( C.layer == 20 ){
				holeCount++;
				}
			}
		}  //end board loop

	return holeCount;

	}  //end func

real tolerance = getTolerance();

string getEmnBoardOutline(){

	/*
	Board outline logic
	--------------------
	1. Loop thru wires on layer 20 and parse out points based on type of wire. 
	   Wire can be either arc or line. If it is an arc then the .arc property is set to 1.

	2. For lines extract the start and end points. For arcs you need to convert them in 
	   to a set of lines that simulates an arc by drawing a line at angle increments. 

	3. After looping thru the wires on layer 20 verify that wires were actually found.
	   If none were found then exit the ulp and notify the user no lines were found on layer 20.

	4. Once the points are loaded to the array they need to reordered so that they are written in the correct order in the outline. 
	   To accomplish this you need to first fine the start point. I do this by finding the point closest to 0,0.

	5. Once the line with a start point closest to 0,0 is found I then look thru the points to find a match for the end point of the first line. 
	   The lines may not be written in end point to start point so you need to check for closet match on both the start and end.

	6. After sorting the lines you can now write out the points to the board_outline section. I check for matches from end to start points.
	  If a match isnt found then I assume a new outline is found and increment the counter. I also need to make sure that when a new outline is found that the prev
	  outline is closed.
	*/

	//init vars
	int debug = 1; //used for debugging and generation of log in board outline processing
	string logFilePath = filesetext( getBoardPath(), ".log" );
	string boardThickness = getBoardThickness();
	string boardOutlineSection = ".BOARD_OUTLINE UNOWNED\n" + boardThickness + "\n";
	int wireCount = 0;

	string outlinePoints[]; //holds points extracted from board
	string outlinePointsSorted[];  //holds points after they are sorted

	real deg2rad = 0.0174532925;  //used to convert degress to radians for arc parsing

	real bx1 = 0.0, by1 = 0.0, bx2 = 0.0, by2 = 0.0;  //line start and end points
	real startX = 0.0, startY = 0.0;
	int outlineNum = 0;

	//used for drawing arc lines
	real incx = 0.0, incy = 0.0;  //store incremental x/y values for arc
	real currentAngle = 0.0, incrementAngle = 15.0;

	string temp;  //temp string used with sprintf

	int  newOutline = 1;
	string pad = "     ";

	real minDist = -1.0;  //used to keep track of min distance found
	real dist = 0.0; //used to store distance between two points

	string fromPoints, toPoints;
	string boardOutlineSectionDebug;

	int matchFound = 0;

	/*   Step 1 & 2   */
	//loop thru layer 20 and wires on layer
	board( BRD ){
		//loop thru wires
		BRD.wires(W){

			//only pull layer 20 wires
			if (W.layer == 20){
				//get wire start and end points
				
				
				bx1 = getDimInBoardUnits(W.x1), 
						by1 = getDimInBoardUnits(W.y1),
						bx2 = getDimInBoardUnits(W.x2), 
						by2 = getDimInBoardUnits(W.y2);

				

				//handle arcs and lines differently
				if ( W.arc ){

					//for arc get data to generate points
					real angle1=W.arc.angle1, 
							angle2=W.arc.angle2, 
							centerx=getDimInBoardUnits(W.arc.xc), 
							centery= getDimInBoardUnits(W.arc.yc);

					real endx = bx2, endy = by2;  //store arc end points to close arc.

					//reset current angle value
					currentAngle = incrementAngle;

					//determine which direction to draw arc by getting x/y points based on angle1
					incx = (cos( deg2rad * (angle1) )*getDimInBoardUnits( W.arc.radius ) ) + centerx;
					incy = (sin( deg2rad * (angle1) )*getDimInBoardUnits( W.arc.radius ) ) + centery;

					//check if arc start points match calculated start points using angle1. if they do then its a counter clockwise drawn arc
					if( compareReals( incx, bx1 ) && compareReals( incy, by1 ) ){

						///loop thru 5 deg increments
						//arc defined counter clockwise so you need to subtract the increment
						while( ( angle1 + currentAngle ) < angle2 ){

							incx = (cos( deg2rad * (angle1 + currentAngle) )*getDimInBoardUnits( W.arc.radius ) ) + centerx;
							incy = (sin( deg2rad * (angle1 + currentAngle) )*getDimInBoardUnits( W.arc.radius ) ) + centery;

							sprintf( temp ,"%f\t%f\t%f\t%f\tn\n", bx1, by1, incx, incy );

							outlinePoints[ wireCount ] = temp;

							currentAngle += incrementAngle;

							wireCount++;

							//update beginning x/y values
							bx1 = incx;
							by1 = incy;
							}  //end while

						}
					else{
						///loop thru 5 deg increments
						//arc defined counter clockwise so you need to subtract the increment
						while( ( angle2 - currentAngle ) > angle1 ){

							incx = (cos( deg2rad * (angle2 - currentAngle) )*getDimInBoardUnits( W.arc.radius ) ) + centerx;
							incy = (sin( deg2rad * (angle2 - currentAngle) )*getDimInBoardUnits( W.arc.radius ) ) + centery;

							sprintf( temp ,"%f\t%f\t%f\t%f\tn\n", bx1, by1, incx, incy );

							outlinePoints[ wireCount ] = temp;

							currentAngle += incrementAngle;

							wireCount++;

							//update beginning x/y values
							bx1 = incx;
							by1 = incy;
							}  //end while
						}  //end if/else for check on direction of arc

					//close arc
					sprintf( temp ,"%f\t%f\t%f\t%f\tn\n", bx1, by1, endx, endy );

					outlinePoints[ wireCount ] = temp;

					wireCount++;
					}
				else{
					//process lines
					sprintf( temp ,"%f\t%f\t%f\t%f\tn\n", bx1, by1, bx2, by2 );

					outlinePoints[ wireCount ] = temp;

					wireCount++;

					}  //end if for arc
				}  //end if check for layer=20
			}  //end loop thru wires
		}  //end loop thru board

	/*   Step 3 - Verify wires found   */
	//make sure wires were found
	if( wireCount == 0 ){
		if( countWireHoles() > 0 ){

			board( B ){
				B.circles( C ){

					real angle1 = 0;
					real angle2 = 360;

					real currentAngle = 0;

					real radius = getDimInBoardUnits( C.radius );
					real centerx = getDimInBoardUnits( C.x );
					real centery = getDimInBoardUnits( C.y );
					real bx1 = centerx + radius;
					real by1 = centery;


					while( ( angle1 + currentAngle ) <= angle2 ){

						incx = (cos( deg2rad * (angle1 + currentAngle) )*radius ) + centerx;
						incy = (sin( deg2rad * (angle1 + currentAngle) )*radius ) + centery;

						sprintf( temp ,"%f\t%f\t%f\t%f\tn\n", bx1, by1, incx, incy );

						outlinePoints[ wireCount ] = temp;

						currentAngle += incrementAngle;

						wireCount++;

						//update beginning x/y values
						bx1 = incx;
						by1 = incy;
						}  //end while

					//close loop
					/*
					sprintf( temp ,"%f\t%f\t%f\t%f\tn\n", bx1, by1, (centerx + radius), centery );

					outlinePoints[ wireCount ] = temp;

					wireCount++;
					*/

					}  //end circle loop

				}  //end board loop
			//exit(0);
			}
		else{
			dlgMessageBox( "No wires were found on layer 20.\nUnable to detect board outline. Exiting." );
			exit(0);
			}
		}  //end if

	if( debug ){
		boardOutlineSectionDebug += "########### array before sorts ###########\n";

		for( int j = 0; j < wireCount; j++ ){
			sprintf( temp ,"%d\t%s", j, outlinePoints[ j ] );

			boardOutlineSectionDebug += temp;
			}  //end for
		}  //end if

/*
	//calculate tolerance based on 1/2 of smallest wire length
	for( int i = 0; i < wireCount; i++ ){
		bx1 = getX1FromPtString( outlinePoints[ i ] );
		by1 = getY1FromPtString( outlinePoints[ i ] );
		bx2 = getX2FromPtString( outlinePoints[ i ] );
		by2 = getY2FromPtString( outlinePoints[ i ] );

		dist = getDistBetweenPts( bx1, by1, bx2, by2 );

		if( minDist == -1.0 ){
			minDist = dist;
			}
		else if( dist < minDist ){
			minDist = dist;
			}
		else{
			//do nothing if dist is not smaller then minDist
			}
		}  //end for loop

	tolerance = minDist / 2;
	*/

	/*   Step 4 & 5 - Verify wires found   */
	//loop thru points and sort so they are in order
	//outer loop thru points
	boardOutlineSectionDebug += "Tolerance=" + rtos( tolerance ) + ".\n";

	for( int i = 0; i < wireCount; i++ ){

		//boardOutlineSection += itos( outlineNum ) + pad + 
		//						rtos( getX1FromPtString( outlinePoints[ i ] ) ) + pad + 
		//						rtos( getY1FromPtString( outlinePoints[ i ] ) ) + pad + "0\n";

		outlinePoints[ i ] = setUsedFlag( outlinePoints[ i ] );

		//get line end points
		bx2 = getX2FromPtString( outlinePoints[ i ] );
		by2 = getY2FromPtString( outlinePoints[ i ] );

		//handle initializations, new outlines, and closed outline checks.
		if( i == 0 ){
			startX = getX1FromPtString( outlinePoints[ i ] );
			startY = getY1FromPtString( outlinePoints[ i ] );

			boardOutlineSection += itos( outlineNum ) + pad + 
									rtos( getX1FromPtString( outlinePoints[ i ] ) ) + pad + 
									rtos( getY1FromPtString( outlinePoints[ i ] ) ) +pad +  "0\n";

			newOutline = 0;
			}
		else if( newOutline ){
			startX = getX1FromPtString( outlinePoints[ i ] );
			startY = getY1FromPtString( outlinePoints[ i ] );

			boardOutlineSection += itos( outlineNum ) + pad + 
									rtos( getX1FromPtString( outlinePoints[ i ] ) ) + pad + 
									rtos( getY1FromPtString( outlinePoints[ i ] ) ) + pad + "0\n";

			newOutline = 0;
			}
		//check if point closes outline
		else if( getDistBetweenPts( startX, startY, getX2FromPtString( outlinePoints[ i ] ), getY2FromPtString( outlinePoints[ i ] ) ) == 0 ){
			boardOutlineSection += itos( outlineNum ) + pad + 
												rtos( getX2FromPtString( outlinePoints[ i ] ) ) + pad + 
												rtos( getY2FromPtString( outlinePoints[ i ] ) ) + pad + "0\n";

			outlineNum++;

			newOutline = 1;

			continue;
			}  //end if
		else if( getDistBetweenPts( startX, startY, getX2FromPtString( outlinePoints[ i ] ), getY2FromPtString( outlinePoints[ i ] ) ) <= tolerance ){
			boardOutlineSection += itos( outlineNum ) + pad + 
												rtos( startX ) + pad + 
												rtos( startY ) + pad + "0\n";

			outlineNum++;

			newOutline = 1;

			continue;
			}  //end if

		matchFound = 0;

		//inner loop thru points to find matching line
		for( int j = 0; j < wireCount; j++ ){

			//boardOutlineSectionDebug += "Checking points for i=" + itos( i ) + " and j=" + itos( j ) + ".\n";

			//check if line is already used. if it is then skip it
			if( !isUsedPoint( outlinePoints[ j ] ) ){

				//check for exact match on line start
				if( getDistBetweenPts( bx2, by2, getX1FromPtString( outlinePoints[ j ] ), getY1FromPtString( outlinePoints[ j ] ) ) == 0 ){
					
					boardOutlineSectionDebug += "*Exact match for i=" + itos( i ) + " and j=" + itos( j ) + ".\n";
					boardOutlineSectionDebug += "*i point " + outlinePoints[ i ];

					boardOutlineSection += itos( outlineNum ) + pad + 
									rtos( getX1FromPtString( outlinePoints[ j ] ) ) + pad + 
									rtos( getY1FromPtString( outlinePoints[ j ] ) ) + pad + "0\n";

					//flag points as used
					outlinePoints[ j ] = setUsedFlag( outlinePoints[ j ] );

					//swap matched point with current point
					//outlinePoints = swapPoints( outlinePoints, (i+1), j );

					toPoints = outlinePoints[ j ];
					fromPoints = outlinePoints[ (i+1) ];

					//move toIndex to from position
					outlinePoints[ (i+1) ] = toPoints;
					outlinePoints[ j ] = fromPoints;

					matchFound = 1;

					break;
					}
				//check for exact match on line end
				else if( getDistBetweenPts( bx2, by2, getX2FromPtString( outlinePoints[ j ] ), getY2FromPtString( outlinePoints[ j ] ) ) == 0 ){
					boardOutlineSectionDebug += "*Exact match for i=" + itos( i ) + " and j=" + itos( j ) + ".\n";
					boardOutlineSectionDebug += "*i point " + outlinePoints[ i ];

					boardOutlineSection += itos( outlineNum ) + pad + 
									rtos( getX2FromPtString( outlinePoints[ j ] ) ) + pad + 
									rtos( getY2FromPtString( outlinePoints[ j ] ) ) + pad + "0\n";

					//flag point as used
					outlinePoints[ j ] = setUsedFlag( outlinePoints[ j ] );

					boardOutlineSectionDebug += "\t*Before flip \t" + outlinePoints[ j ];

					//flip point
					outlinePoints[ j ] = flipPoints( outlinePoints[ j ] );

					boardOutlineSectionDebug += "\t*After flip \t" + outlinePoints[ j ];

					//swap matched point with current point
					//outlinePoints = swapPoints( outlinePoints, (i+1), j );

					toPoints = outlinePoints[ j ];
					fromPoints = outlinePoints[ (i+1) ];

					//move toIndex to from position
					outlinePoints[ (i+1) ] = toPoints;
					outlinePoints[ j ] = fromPoints;

					matchFound = 1;

					break;
					}
				//check for tolerance match on line start
				else if( getDistBetweenPts( bx2, by2, getX1FromPtString( outlinePoints[ j ] ), getY1FromPtString( outlinePoints[ j ] ) ) <= tolerance ){

					boardOutlineSectionDebug += "*Tolerance match for i=" + itos( i ) + " and j=" + itos( j ) + ". Dist=" + rtos( getDistBetweenPts( bx2, by2, getX1FromPtString( outlinePoints[ j ] ), getY1FromPtString( outlinePoints[ j ] ) ) ) + "\n";
					boardOutlineSectionDebug += "*i point " + outlinePoints[ i ];

					boardOutlineSection += itos( outlineNum ) + pad + 
									rtos( bx2 ) + pad + 
									rtos( by2 ) + pad + "0\n";

					boardOutlineSectionDebug += "\t*Before fix for tolerance \t" + outlinePoints[ j ];

					
					//update matched point start points to prev line end points to fix the gap
					sprintf( temp ,"%f\t%f\t%f\t%f\tn\n", bx2, by2, getX2FromPtString( outlinePoints[ j ] ), getY2FromPtString( outlinePoints[ j ] ) );

					outlinePoints[ j ] = temp;

					boardOutlineSectionDebug += "\t*After fix for tolerance \t" + outlinePoints[ j ];

					//flag points as used
					outlinePoints[ j ] = setUsedFlag( outlinePoints[ j ] );

					//swap matched point with current point
					//outlinePoints = swapPoints( outlinePoints, (i+1), j );

					toPoints = outlinePoints[ j ];
					fromPoints = outlinePoints[ (i+1) ];

					//move toIndex to from position
					outlinePoints[ (i+1) ] = toPoints;
					outlinePoints[ j ] = fromPoints;

					matchFound = 1;

					break;
					}
				//check for tolerance match on line end
				else if( getDistBetweenPts( bx2, by2, getX2FromPtString( outlinePoints[ j ] ), getY2FromPtString( outlinePoints[ j ] ) ) <= tolerance ){

					boardOutlineSectionDebug += "*Tolerance match for i=" + itos( i ) + " and j=" + itos( j ) + ". Dist=" + rtos( getDistBetweenPts( bx2, by2, getX2FromPtString( outlinePoints[ j ] ), getY2FromPtString( outlinePoints[ j ] ) ) ) + "\n";
					boardOutlineSectionDebug += "*i point " + outlinePoints[ i ];

					boardOutlineSection += itos( outlineNum ) + pad + 
									rtos( bx2 ) + pad + 
									rtos( by2 ) + pad + "0\n";

					boardOutlineSectionDebug += "\t*Before fix for tolerance \t" + outlinePoints[ j ];
					
					//update matched point start points to prev line end points to fix the gap
					sprintf( temp ,"%f\t%f\t%f\t%f\tn\n", getX1FromPtString( outlinePoints[ j ] ), getY1FromPtString( outlinePoints[ j ] ), bx2, by2 );

					outlinePoints[ j ] = temp;

					boardOutlineSectionDebug += "\t*After fix for tolerance \t" + outlinePoints[ j ];

					//flag points as used
					outlinePoints[ j ] = setUsedFlag( outlinePoints[ j ] );

					boardOutlineSectionDebug += "\t*Before flip \t" + outlinePoints[ j ];

					//flip point
					outlinePoints[ j ] = flipPoints( outlinePoints[ j ] );

					boardOutlineSectionDebug += "\t*After flip \t" + outlinePoints[ j ];

					//swap matched point with current point
					//outlinePoints = swapPoints( outlinePoints, (i+1), j );

					toPoints = outlinePoints[ j ];
					fromPoints = outlinePoints[ (i+1) ];

					//move toIndex to from position
					outlinePoints[ (i+1) ] = toPoints;
					outlinePoints[ j ] = fromPoints;

					matchFound = 1;

					break; 
					}
				//else line has not matching point. 
				else{
					//boardOutlineSectionDebug += "No match for i=" + itos( i ) + " and j=" + itos( j ) + ".\n";
				
					}  //end if-else

				}
			else{
				//do nothing for skipped line
				//boardOutlineSectionDebug += "Points skipped for i=" + itos( i ) + " and j=" + itos( j ) + ".\n";
				}  //end if/else

			}  //end j loop

		//check to make sure a matching point was found. if not notify user and mark on board.
		if( !matchFound ){
			boardOutlineSectionDebug += "No match for i=" + itos( i ) +  ".\n";


			//if no match found then generate circle command and exit.
			string circleDefectCommands;
			string runCommands;

			sprintf( circleDefectCommands, "CIRCLE (%f %f) (%f %f);", backConvertDimensions( bx2 ), 
																		backConvertDimensions( by2 ), 
																		backConvertDimensions( bx2+2.0 ), 
																		backConvertDimensions( by2 ) );

			//delete existing debug layer if it exists
			runCommands += removeIDFDebugLayerCommands();

			//get debug layer number
			string debugLayerNum = getIDFDebugLayerAvailNum();


			//dlgMessageBox( "A fatal defect was found in your board outline in the form\n" +
			//	"of a gap in the board outline. We cannot repair this defect.\n\n" + 
			//	"Defects will be shown on layer " + debugLayerNum + " with red circles." );

			dlgMessageBox( "An error was found in your board outline that cannot be automatically repaired.  Outlines must be enclosed loops.\n" +
							"Defects will be shown on layer " + debugLayerNum + " with red circles." );

			string wireCommands = "change width 0.01;\nSET Wire_Bend 2;\n";

			if( debug ){
				boardOutlineSectionDebug += "########### array after sorts ###########\n";

				//build wire commands that will draw the outlines that have been matched. the last wire will be drawn but it has no match
				for( int j = 0; j < wireCount; j++ ){
					sprintf( temp ,"%d\t%s", j, outlinePoints[ j ] );
					boardOutlineSectionDebug += temp;

					if( isUsedPoint( outlinePoints[ j ] ) ){
						wireCommands += "WIRE ( " + rtos( backConvertDimensions( getX1FromPtString( outlinePoints[ j ] ) ) ) + " " + 
													rtos( backConvertDimensions( getY1FromPtString( outlinePoints[ j ] ) ) ) +  ") (" + 
													rtos( backConvertDimensions( getX2FromPtString( outlinePoints[ j ] ) ) ) + " " + 
													rtos( backConvertDimensions( getY2FromPtString( outlinePoints[ j ] ) ) )+ ");";
						}
					}  //end for
				}  //end if
	
			//circleDefectCommands = "LAYER 100 IDFDebug;SET COLOR_LAYER 100 red;CHANGE WIDTH 0.01;" + 
			//removed change width comand
			runCommands += "LAYER " + debugLayerNum + " IDFDebug;" + 
									"SET COLOR_LAYER " + debugLayerNum + " red;" + 
									circleDefectCommands + wireCommands + 
									"DISPLAY NONE;" + 
									"DISPLAY 20 " + debugLayerNum + ";" +
									"WINDOW FIT;";
			

			if( debug ){
				writeToFile( logFilePath, boardOutlineSectionDebug + "***************\n" + runCommands + "***************\n" + boardOutlineSection );
				}
			
			exit( runCommands );
			}  //end if for matchfound


		}  //end i loop

	if( debug ){
		boardOutlineSectionDebug += "########### array after sorts ###########\n";

		for( int j = 0; j < wireCount; j++ ){
			sprintf( temp ,"%d\t%s", j, outlinePoints[ j ] );

			boardOutlineSectionDebug += temp;
			}  //end for
		}  //end if


	if( debug ){
		writeToFile( logFilePath, boardOutlineSectionDebug+ "***************\n" + boardOutlineSection );
		}

	boardOutlineSection += ".END_BOARD_OUTLINE\n";

	//exit(0);
	
	return boardOutlineSection;
	}  //end getEmnBoardOutline 




string getEmnDrilledHoles(){
	/*
	.DRILLED_HOLES
	40.0 1773.0 1207.5 PTH S1 PIN ECAD
	40.0 1773.0 1384.5 PTH S1 PIN ECAD
	40.0 2029.0 1207.5 PTH S1 PIN ECAD
	...
	.END_DRILLED_HOLES
	*/

	string drilledHolesSection = ".DRILLED_HOLES\n";
	string temp;

	int holeCount = 0;

	board( BRD ){
		//loop thru holes
		BRD.holes(H){ 
			sprintf( temp, "%10.4f%10.4f%10.4f  NPTH  BOARD OTHER UNOWNED\n", (getDimInBoardUnits(H.drill)), (getDimInBoardUnits(H.x)), (getDimInBoardUnits(H.y)) ); 

			drilledHolesSection += temp;

			holeCount++;
			}  //end holes

		//get any holes from packages on elements
		BRD.elements(E){ 
			E.package.holes(C){ 
				sprintf( temp, "%10.4f%10.4f%10.4f  NPTH  %-4s PIN UNOWNED\n", (getDimInBoardUnits(C.drill)), (getDimInBoardUnits(C.x)), (getDimInBoardUnits(C.y)), E.name ); 

				drilledHolesSection += temp;

				holeCount++;
				}  //end package.holes


			E.package.contacts(P){
				if (P.pad){
					sprintf( temp, "%.2f %.2f %.2f PTH BOARD VIA UNOWNED\n", getDimInBoardUnits(P.pad.drill), getDimInBoardUnits(P.x), getDimInBoardUnits(P.y) ); 

					drilledHolesSection += temp;

					holeCount++;
					}  //end if
				}  //end loop thru contacts

			}  //end elements

		//get any holes on vias
		BRD.signals(S){
			S.vias(V){ 
				sprintf( temp, "%10.4f%10.4f%10.4f  NPTH  BOARD OTHER UNOWNED\n", (getDimInBoardUnits(V.drill)), (getDimInBoardUnits(V.x)), (getDimInBoardUnits(V.y)) ); 

				drilledHolesSection += temp;

				holeCount++;
				}
			}
		}  //end board loop


	//close drilled holes section
	drilledHolesSection += ".END_DRILLED_HOLES\n";

	//check if drilled holes is empty and if so clear it
	if( holeCount == 0 ){
		drilledHolesSection = "";
		}

	return drilledHolesSection;
	}  //end sub


string getEmnPlacements(){
	/*
	.PLACEMENT
	0805 RES R4
	2300.0 1275.0 0.0 180.0 TOP PLACED
	0805 CAP C13
	2565.0 1380.0 0.0 0.0 TOP PLACED

	<footprint>  <altname>   <refid>
	<x>   <y>  <?>  <rot>  <top/bottom>  <placed>

	...
	.END_PLACEMENT
	*/


	string sideMap[] = {"TOP","BOTTOM"};

	string placementSection;

	string footprint; 
	string altname;
	string ref_id;

	string components[];

	string component;

	string temp;

	string side;

	string libraryLookup; //used to check if library is in array


	placementSection = ".PLACEMENT\n";

	//loop thru elements on board
	board( BRD ){

		int i = 0;

		BRD.elements( E ){

			//get footprint and altname
			/*
			1. If an item is in the rcl or the resistor library, I would like the Package Name to be written out 
			   in the first two fields of the emn and emp files regardless of whether or not the ?value? field is empty or populated.
			2. if value populated then use it for footprint
			3. concatenate name (ref id) and package for footpring
			*/

			//check if package library is in list
			//if( strupr(E.package.library) == "RCL" || strupr(E.package.library) == "RESISTOR" ){

			//look up package library in libraries array
			//check if element has already been written out
			libraryLookup = lookup( libraries, strupr(E.package.library), 0 );


			//debug
			if( debug ){
				dlgMessageBox( libraryLookup );
				}

			//logic to setup footprint an altname values
			if( libraryLookup != "" ){
				//if found in libraryLookup then assign package name to both footprint and altname
				altname = E.package.name;
				footprint = E.package.name;
				}
			else if( E.value != "" ){
				//if e.value is not empty then put it in the footprint
				altname = E.value;
				footprint = E.package.name;
				}
			else{
				//if library is not in list and the E.value is blank then concat refid and package name
				altname = E.name + "_" + E.package.name;
				footprint = E.package.name;
				}  //end if-else

			//make sure footprint and altname dont have spaces
			//if( strstr( footprint, " " ) >= 0 ){
			//	footprint = replaceSpaceWithUnderscore( footprint );
			//	}

			footprint = cleanString( footprint );

			//if( strstr( altname, " " ) >= 0 ){
			//	altname = replaceSpaceWithUnderscore( altname );
			//	}

			altname = cleanString( altname );

			//parse out ref id earlier and check for spaces
			ref_id = E.name;

			//if( strstr( ref_id, " " ) >= 0 ){
			//	ref_id = replaceSpaceWithUnderscore( ref_id );
			//	}

			ref_id = cleanString( ref_id );

			//get side value based on mirror value
			side = sideMap[ E.mirror ];

			sprintf( temp, "%s %s %s\n%f %f 0 %f %s PLACED\n", footprint, altname, ref_id, getDimInBoardUnits( E.x ), getDimInBoardUnits( E.y ), E.angle, side );
			//sprintf( temp, "%s %s %s\nPLACED\n", footprint, E.package.name, E.name );

			placementSection += temp;

			//add component to components list
			//components[ i ] = footprint; - fix for emp missing values

			components[ i ] = footprint + "~" + altname;

			i++;

			}  //end loop thru elements
		}  //end loop thru board



	placementSection += ".END_PLACEMENT\n";


	return placementSection;

	}  //end sub

string generateEmn(){

	//build emn file
	string emn = getEmnHeader() + 
					getEmnBoardOutline() + 
					getEmnDrilledHoles() + 
					getEmnPlacements();

	return emn;
	}  //end sub

string generateEmp(){

	//build emp file
	string emp = getEmpHeader() +
					getEmpElectrical() +
					getEmpMechanical();

	return emp;
	}  //end sub

/*
void generateEmnEmpFiles(){

	//build emn file
	string emn = getEmnHeader() + 
					getEmnBoardOutline() + 
					getEmnDrilledHoles() + 
					getEmnPlacements();


	//build emp file
	string emp = getEmpHeader() +
					getEmpElectrical() +
					getEmpMechanical();


	//write out for now
	output( "C:/Users/Marco/Documents/Eagle Programs/emn.emn", "w" ){
		printf( emn );
		}

	output( "C:/Users/Marco/Documents/Eagle Programs/emp.emp", "w" ){
		printf( emp );
		}
	}  //end sub
*/

//Submits emn and emp data to IDF site. IDF returns full html page.
void submitFormData(){

	//update user now as the post will take some time to start
	textMessageDialog = getHtmlText( "<font size=5 color=green>3D build request submitted. Please wait for update...</font>" );

	dlgRedisplay();

	if( debug ){
		dlgMessageBox( path_ulp[0] );
		}


	//get board name
	string boardName;
	string boardDir;

	board( BRD ){
		boardName = filename( BRD.name );

		boardDir = filedir( BRD.name );
		}  //end board

	//demo stuff
	/*
	string demoPath = "C:/Users/Marco/Documents/Eagle Programs/";
	string emnData = parseFileToHtmlForm( path_ulp[0] + "/" + "eagleto3ddemo.emn" ) + "\n";
	string empData = parseFileToHtmlForm( path_ulp[0] + "/" + "eagleto3ddemo.emp" ) + "\n";
	*/

	//get emn and emp strings
	string emnData = generateEmn() + "\n";
	string empData = generateEmp() + "\n";

	//debug
	
	if( 0 ){
		//boardDir = "/Users/marcbattistello/";  //hardcode since write issues to program files
		boardDir = "C:/Users/Marco/Desktop/";

		//show path to user
		dlgMessageBox( "Writing IDF Files: " + boardDir + filesetext( boardName, ".emn") );

		output( boardDir + filesetext( boardName, ".emn"), "wt" ){
			printf( emnData );
			}

		output( boardDir + filesetext( boardName, ".emp"), "wt" ){
			printf( empData );
			}
		}  //end if
		
	//exit(0);

	//convert to html format
	emnData = parseStringToHtmlForm( emnData );
	empData = parseStringToHtmlForm( empData );

	//debug
	if( debugIDFHtml ){
		output( boardDir + filesetext( boardName, ".html_emn"), "w" ){
			printf( emnData );
			}

		output( boardDir + filesetext( boardName, ".html_emp"), "w" ){
			printf( empData );
			}
		}  //end if


	//data for url post
	string postResponse;
	string postData;
	int requestSubmitted = 0;

	string urlParams;

	//strings used to build some html elements
	string tempStr;
	string thumbnailImg;
	string pdf3dLink;
	string thumbnailLink;

	string purchaseStlLink;
	string purchaseDownloadLink;
	string complete3DDesignLink;

	//response data
	string jobId;
	string jobStatus;
	string percentComplete;
	string sessionKey;

	string downloadPurchaseUrl;
	string stlPurchaseUrl;
	string complete3DDesignUrl;

	int jobCompleted = 0;

	//loop thru form post
	for( int i = 0; i < 50000; i++ ){

		//only check every 10th loop
		if( i % 10 == 0 ){

			//check if request has already been submitted
			if( !requestSubmitted ){
				//check if secondary mapping flag set
				if( useSecondaryMappings ){
					//load data to post parameters
					sprintf( postData,"emn=%s\nemp=%s\nboardname=%s\nsecondary=y\nversion=" + version, emnData, empData, boardName );
					}
				else{
					sprintf( postData,"emn=%s\nemp=%s\nboardname=%s\nversion=" + version, emnData, empData, boardName );
					}
				
				}
			else{
				//load data to post parameters
				sprintf( postData,"id=%s", jobId );


				if( useSecondaryMappings ){
					//load data to post parameters
					sprintf( postData,"id=%s\nsecondary=y", jobId );
					}
				else{
					sprintf( postData,"id=%s", jobId );
					}
				}  //end if-else

			if( netpost( postResponse, service_url, postData ) >= 0 ) {

				if( debug ){
					dlgMessageBox( postResponse );
					}

				//after first request set to 1/true
				requestSubmitted = 1;

				//parse xml response data
				jobStatus = xmltext( postResponse, "response/status" );
				jobId = xmltext( postResponse, "response/id" );
				percentComplete = xmltext( postResponse, "response/percent_complete" );
				sessionKey = xmltext( postResponse, "response/session_key" );

				//get response and parse. first check status
				if( jobStatus == "ERROR" ){
					//post error to user
					textMessageDialog = getHtmlText( "Error in netpost. Please try submit again. If error persists contact support. <a href=\"mailto:support@simplifiedsolutionsinc.com?subject=EAGLE-to-3D%20Support\">Contact Support</a>" );

					dlgRedisplay();

					break;
					}
				else if( jobStatus == "ACTIVE" || jobStatus == "NOT STARTED" || jobStatus == "not started" ){
					
					//sprintf( tempStr, "%s<h2>Request is active. Percent Complete: %s</h2>", tagImgActive, percentComplete);
					sprintf( tempStr, "<font size=5 color=green>Request is active.</font><BR/><br/><font size=5>Percent Complete: %s%%</font>", percentComplete );

					textMessageDialog = getHtmlText( tempStr );

					}
				else if( jobStatus == "COMPLETE" ){
					//set job complete flag
					jobCompleted = 1;

					//get link from xml response
					downloadPurchaseUrl = xmltext( postResponse, "response/betaDownloadKey" );
					stlPurchaseUrl = xmltext( postResponse, "response/betaStlKey" );
					complete3DDesignUrl = xmltext( postResponse, "response/betaComplete3DDesignKey" );


					if( debug ){
						dlgMessageBox( postResponse );
						}


					if( debug ){
						dlgMessageBox( stlPurchaseUrl );
						}

					

					//build image link
					sprintf( thumbnailImg, "<img src=\"https://www.simplifiedsolutionsinc.com/EMN-EMPAdvancedApp/GetSessionDataFromDBServlet?id=%s&type=jpg\" width=\"300\" alt=\"If Image Missing Re-Generate 3D Data\">", sessionKey);

					sprintf( thumbnailLink, "<a href=\"https://www.simplifiedsolutionsinc.com/EMN-EMPAdvancedApp/GetSessionDataFromDBServlet?id=%s&type=jpg\">Open Larger Thumbnail - Free</a>", sessionKey);

					sprintf( pdf3dLink, "<a href=\"https://www.simplifiedsolutionsinc.com/EMN-EMPAdvancedApp/GetSessionDataFromDBServlet?id=%s&type=pdf\">Click here</a>", sessionKey);

					//links for purchase
					sprintf( purchaseDownloadLink, "<a href=\"%s\">Click here</a>", downloadPurchaseUrl );

					sprintf( purchaseStlLink, "<a href=\"%s\">Click here</a>", stlPurchaseUrl );

					sprintf( complete3DDesignLink, "<a href=\"%s\">Click here</a>", complete3DDesignUrl );

					if( debug ){
						dlgMessageBox( purchaseStlLink );
						}

					/*
					textMessageDialog_old = getHtmlText( "<h2><b><i>Sending data complete: A session to map your components with our 3D database is ready.</i></b></h2> \
														The picture shows your board and components that could be mapped automatically. \
														<font size=4><table border=0 cellpadding=0 cellspacing=0> \
															<tr> \
																<td width=\"200\">" + thumbnailImg + "<BR><font color=\"red\">Important:</font> Automatic component mapping works only with the original EAGLE Library. Components shown in <font color=\"red\">red</font> can be mapped manually.</td> \
																<td><BR>\
																		&nbsp;&nbsp;&nbsp;&nbsp;<B>" + pdf3dLink + "</B> to open a 3D PDF<br><br> \
																		&nbsp;&nbsp;&nbsp;&nbsp;<B>" + purchaseDownloadLink + "</B> to purchase the 3D-STEP file<br><br> \
																		&nbsp;&nbsp;&nbsp;&nbsp;<B>" + purchaseStlLink + "</B> to purchase a physical 3D model (Rapid Prototype)<br><br> \
																		&nbsp;&nbsp;&nbsp;&nbsp;<B>" + complete3DDesignLink + "</B> to complete the component mapping manually \
																	<ul> \
																		<li>Use of our IDF-to-3D tool is free</li> \
																		<li>Generate a 3D PDF of your 3D Board Assembly at no cost</li> \
																		<li>Incorporate additional 3D Models to your design by using our IDF-to-3D model library and our 3D STEP Model integration tool</li> \
																	</ul> \
																</td> \
															</tr> \
														</table></font>" );
					*/

					textMessageDialog =
								getHtmlText( "<h2><b><i>Generating data complete: A session to map your components with our 3D database is ready.</i></b></h2> \
								The picture shows your board and components that could be mapped automatically. \
								<font size=4><table border=0 cellpadding=0 cellspacing=0> \
								<tr> \
								<td width=\"200\">" + thumbnailImg + "<BR><font color=\"red\">Important:</font> Automatic component mapping works only with the original EAGLE Library. Components shown in <font color=\"red\">red</font> can be mapped manually.</td> \
								<td><BR>\
								&nbsp;&nbsp;&nbsp;&nbsp;<B>" + complete3DDesignLink + "</B> to complete the component mapping manually \
								<ul> \
								<li>Use of our IDF-to-3D tool is free</li> \
								<li>Generate a 3D PDF of your 3D Board Assembly at no cost</li> \
								<li>Incorporate additional 3D Models to your design by using our IDF-to-3D model library and 3D STEP Model integration tool</li> \
								<li>Get a free FITS-OR-NOT 3D Printer Rapid Prototype with every PCB-POOL(R) order</li> \
								</ul> \
								&nbsp;&nbsp;&nbsp;&nbsp;If satisfied with your 3D image:<br><br> \
								&nbsp;&nbsp;&nbsp;&nbsp;<B>" + pdf3dLink + "</B> to open a 3D PDF (Free)<br><br> \
								&nbsp;&nbsp;&nbsp;&nbsp;<B>" + purchaseDownloadLink + "</B> to purchase the 3D-STEP file<br><br> \
								&nbsp;&nbsp;&nbsp;&nbsp;<B>" + purchaseStlLink + "</B> to get a free FITS-OR-NOT Prototype with your PCB-POOL(R) order\
								</td> \
								</tr> \
								</table></font>" );

					//update display
					dlgRedisplay();

					break;
					}
				else{
					textMessageDialog = getHtmlText( "<font color=\"red\">There was an error in your request. Please try submit again. \
										If error persists contact support. \
										<a href=\"mailto:support@simplifiedsolutionsinc.com?subject=EAGLE-to-3D%20Support\">Contact Support</a> <BR/>\
											Error Code:" + neterror() + "</font>" );
					dlgRedisplay();

					break;
					}

				//this is neded to update the text display
				dlgRedisplay();

				}
			else{
				//handle error in netpost
				textMessageDialog = getHtmlText( "We were unable to complete your request at this time. Please try submit again. \
										If error persists contact support. \
										<a href=\"mailto:support@simplifiedsolutionsinc.com?subject=EAGLE-to-3D%20Support\">Contact Support</a> <BR/>\
											Error Code:" + neterror() + "<BR/>Post Response:" + postResponse );

				dlgRedisplay();

				break;
				}  //end if-else
			} 
		else if( i % 3 == 0 ){
			//try to slow down the loop
			}
		else{
			//do nothing.
			
			}//end if-else modulus test

		}  //end for
		



		//alert user to job success
		if( jobCompleted ){
			dlgMessageBox( "Your job is complete" );
			}
		else{
			dlgMessageBox( "Your job ended in error\n Job Status: " + jobStatus );

			textMessageDialog = getHtmlText( "<font color=\"red\">There was an error in your request. Please try submit again. \
										If error persists contact support. \
										<a href=\"mailto:support@simplifiedsolutionsinc.com?subject=EAGLE-to-3D%20Support\">Contact Support</a> <BR/>\
											Error Code:" + neterror() + "</font>" );
			//force text view to update
			dlgRedisplay();
			}  //end if-else

	}  //end sub

//verifies netget works and gets a valid response
//0=network conection failed
//1=network connection was successful
int verifyNetwork(){
	string temp;

	//make network request
	if( netget( temp, service_url ) ){
		return 1;
		}
	else{
		return 0;
		}  //end if-else
	}  //end sub

//make network connection to service url and make sure its working
int verifyIDFService(){
	
	string temp;
	string serviceStatus;
	
	//make network request
	if( netget( temp, service_url ) ){
		serviceStatus = xmltext( temp, "response/status" );

		//debug line
		if( debug ){
			dlgMessageBox( serviceStatus );
			}
	
		if( serviceStatus == "available" ){
			return 1;
			}
		else{
			return 0;
			}  //end if-else on status
		}
	else{
		return 0;
		}  //end if-else for netget call

	}  //end sub
//-----------------------------------------------------------------------------
// main section
//-----------------------------------------------------------------------------


void main(){

	//ulp path. 
	//dlgMessageBox( argv[0] );


	//check to make sure board is loaded
	if( !board ){
		dlgMessageBox(usage + "<hr><b>ERROR: No board!</b><p>\nThis program can only work in the layout editor.</p>");
		exit(-1);
		}

	//validate connectivity
	if( !verifyNetwork() ){
		dlgMessageBox( "<b>ERROR: Network connection failed.</b><p>\nPlease verify your network connection.</p>");
		exit(-1);
		}

	//validate system status
	if( !verifyIDFService() ){
		dlgMessageBox( "<b>ERROR: The EAGLE to 3D webservice is unavailable.</b><p>\nUnable to connect to EAGLE to 3D web service.\nPlease try again later.</p>");
		//exit(-1);
		}



	//on open load banner and libraries
	loadBanner();

	loadLibraries();


	//analyze board and library to identify and issues that would prevent the successful generation of a emn and emp file

	//set initial text view content
	textMessageDialog = getHtmlText( tagBanner + " \
											<table><tr><td colspan=2><font size=\"4\"><b>Sample 3D Output</b> - Click the \"Generate 3D Data\" button to send your data to our IDF-to-3D server.</font></td></tr><tr><td> \
											<img src=\"https://www.simplifiedsolutionsinc.com/images/3dpcb.jpg\" width=\"300\"></td> \
											<td><BR><font size=\"4\">We offer:<ul> \
												<li>One button click automated conversion from EAGLE to a full 3D model</li> \
												<li>Automated component mapping to thousands of EAGLE library components</li> \
												<li>Electronic Downloads (STEP Format) and rapid prototypes of your populated 3D Boards</li> \
												</ul> \
												</font> \
											</td></tr>" );

	//show dialog to user
	int mainDlgResult = dlgDialog( "EAGLE to 3D" ) {
		//main layout
		dlgVBoxLayout {

			//set width
			if( isWindows() ){
				//windows
				dlgHBoxLayout dlgSpacing( 800 );  //sets width
				}
			else{
				//mac/linux
				dlgHBoxLayout dlgSpacing( 850 );  //sets width
				}  //end if-else
			
			//set height and text view
			dlgHBoxLayout {
				dlgTextView( textMessageDialog );  //text view. holds html 

				if( isWindows() ){
					//windows
					dlgVBoxLayout dlgSpacing( 525 );  //sets height
					}
				else{
					//mac/linux
					dlgVBoxLayout dlgSpacing( 600 );  //sets height
					}  //end if-else

				
				}  //end box layout

			//add option for secondary mappings
			dlgHBoxLayout {
				dlgCheckBox( "Enable 3D Mapping Assumptions - Enable representative 3D geometry \nwhen EAGLE supplied libraries are not utilized", useSecondaryMappings);

				dlgLabel( "( <a href=\"https://www.simplifiedsolutionsinc.com/EagleTo3D/ulp_secondary_mapping_help.htm\">What is this?</a> )" );

				//dlgStretch( 25 );

				dlgLabel( "|\n|\n" );

				if( isWindows() ){

					dlgStretch(50);
					}
				
				dlgLabel("Board Thickness (MM):");

				dlgStringEdit( boardThickness );

				//dlgLabel("MM");

				//dlgStretch(100);

				}  //end box layout



			//buttons to submit and exit
			dlgHBoxLayout {
				dlgPushButton( "Generate 3D Data" ) {

					//build emn and emp strings
					//generateEmnEmpFiles();

					//submit data to idf site
					submitFormData();
					}  //end button
				dlgPushButton( "Exit" ) dlgReject();
				}  //end box layout
			}  //end v box layout
		};  //end mainDlgResult

	}  //end main
